import * as fs from 'fs';
import * as path from 'path';
import { ToolExecutor, ToolMetadata } from '../ToolRegistry';

interface SecurityVulnerability {
    file: string;
    line: number;
    column?: number;
    severity: 'critical' | 'high' | 'medium' | 'low' | 'info';
    type: 'injection' | 'xss' | 'auth' | 'crypto' | 'secrets' | 'dependencies' | 'configuration' | 'dos';
    category: string;
    title: string;
    description: string;
    impact: string;
    remediation: string;
    cwe?: string; // Common Weakness Enumeration ID
    cvss?: number; // Common Vulnerability Scoring System
    code?: string;
    fix?: {
        description: string;
        suggestion: string;
    };
}

interface SecurityReport {
    summary: {
        totalVulnerabilities: number;
        critical: number;
        high: number;
        medium: number;
        low: number;
        byType: { [type: string]: number };
        riskScore: number; // 0-100
    };
    vulnerabilities: SecurityVulnerability[];
    recommendations: string[];
    compliance: {
        owasp: string[];
        pci: boolean;
        gdpr: boolean;
    };
}

export class SecurityVulnerabilityTool implements ToolExecutor {
    public metadata: ToolMetadata = {
        name: 'security_vulnerability_detection',
        description: 'Comprehensive security vulnerability scanning with OWASP compliance and automated remediation',
        category: 'Security',
        parameters: [
            { name: 'target', description: 'File or directory to scan for security vulnerabilities', required: true, type: 'string' },
            { name: 'scanType', description: 'Scan types: code, dependencies, config, secrets, all (default: all)', required: false, type: 'array' },
            { name: 'severity', description: 'Minimum severity: critical, high, medium, low, info', required: false, type: 'string' },
            { name: 'includeTests', description: 'Include test files in scan (default: false)', required: false, type: 'boolean' },
            { name: 'generateReport', description: 'Generate detailed security report (default: true)', required: false, type: 'boolean' },
            { name: 'autoFix', description: 'Automatically fix low-risk issues (default: false)', required: false, type: 'boolean' },
            { name: 'compliance', description: 'Check compliance: owasp, pci, gdpr (default: owasp)', required: false, type: 'array' }
        ],
        examples: [
            'Full security scan: { "target": "src", "scanType": ["all"] }',
            'Critical issues only: { "target": "src/auth", "severity": "critical" }',
            'Dependency scan: { "target": ".", "scanType": ["dependencies"] }',
            'GDPR compliance: { "target": "src", "compliance": ["gdpr", "owasp"] }'
        ]
    };

    private vulnerabilityPatterns: Array<{
        pattern: RegExp;
        type: SecurityVulnerability['type'];
        category: string;
        title: string;
        description: string;
        impact: string;
        remediation: string;
        severity: SecurityVulnerability['severity'];
        cwe?: string;
        cvss?: number;
        fix?: { description: string; suggestion: string };
    }> = [];

    constructor() {
        this.initializeVulnerabilityPatterns();
    }

    async execute(payload: any, context: {
        workspaceRoot: string;
        outputChannel: any;
        onProgress?: (message: string) => void;
    }): Promise<{ success: boolean; message: string; data?: any }> {
        try {
            context.onProgress?.(`Starting security vulnerability scan: ${payload.target}`);
            
            const targetPath = path.resolve(context.workspaceRoot, payload.target);
            
            if (!targetPath.startsWith(context.workspaceRoot)) {
                throw new Error('Target path outside workspace not allowed');
            }
            
            if (!fs.existsSync(targetPath)) {
                throw new Error(`Target not found: ${payload.target}`);
            }

            const scanTypes = payload.scanType || ['all'];
            const severity = payload.severity || 'info';
            const includeTests = payload.includeTests === true;
            const generateReport = payload.generateReport !== false;
            const autoFix = payload.autoFix === true;
            const compliance = payload.compliance || ['owasp'];

            const vulnerabilities: SecurityVulnerability[] = [];

            // Perform different types of scans
            if (scanTypes.includes('all') || scanTypes.includes('code')) {
                context.onProgress?.('Scanning source code for vulnerabilities...');
                const codeVulns = await this.scanSourceCode(targetPath, includeTests, context.workspaceRoot);
                vulnerabilities.push(...codeVulns);
            }

            if (scanTypes.includes('all') || scanTypes.includes('dependencies')) {
                context.onProgress?.('Scanning dependencies for known vulnerabilities...');
                const depVulns = await this.scanDependencies(context.workspaceRoot);
                vulnerabilities.push(...depVulns);
            }

            if (scanTypes.includes('all') || scanTypes.includes('config')) {
                context.onProgress?.('Scanning configuration files...');
                const configVulns = await this.scanConfiguration(context.workspaceRoot);
                vulnerabilities.push(...configVulns);
            }

            if (scanTypes.includes('all') || scanTypes.includes('secrets')) {
                context.onProgress?.('Scanning for exposed secrets...');
                const secretVulns = await this.scanSecrets(targetPath, context.workspaceRoot);
                vulnerabilities.push(...secretVulns);
            }

            // Filter by severity
            const filteredVulns = this.filterBySeverity(vulnerabilities, severity);

            // Apply auto-fixes if requested
            let fixedCount = 0;
            if (autoFix && filteredVulns.length > 0) {
                context.onProgress?.('Applying automatic fixes for low-risk issues...');
                fixedCount = await this.applyAutoFixes(filteredVulns, context);
            }

            // Generate security report
            const report = this.generateSecurityReport(filteredVulns, compliance);

            // Generate HTML report if requested
            let reportPath: string | undefined;
            if (generateReport) {
                context.onProgress?.('Generating security report...');
                reportPath = await this.generateHtmlReport(report, context.workspaceRoot);
            }

            const message = this.formatResults(report, fixedCount, reportPath);

            return {
                success: true,
                message,
                data: {
                    report,
                    fixedCount,
                    reportPath,
                    summary: {
                        totalScanned: filteredVulns.length,
                        criticalIssues: report.summary.critical,
                        riskScore: report.summary.riskScore,
                        complianceStatus: report.compliance
                    }
                }
            };

        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            context.outputChannel.appendLine(`Security vulnerability scan failed: ${errorMessage}`);
            return { success: false, message: errorMessage };
        }
    }

    private initializeVulnerabilityPatterns(): void {
        this.vulnerabilityPatterns = [
            // Injection Vulnerabilities
            {
                pattern: /eval\s*\(/g,
                type: 'injection',
                category: 'Code Injection',
                title: 'Dangerous eval() usage',
                description: 'The eval() function executes arbitrary JavaScript code, which can lead to code injection attacks',
                impact: 'Arbitrary code execution, data theft, system compromise',
                remediation: 'Avoid eval(). Use JSON.parse() for JSON data or Function constructor for safer alternatives',
                severity: 'critical',
                cwe: 'CWE-95',
                cvss: 9.0,
                fix: {
                    description: 'Replace eval() with safer alternatives',
                    suggestion: 'Use JSON.parse() for JSON data or implement proper validation'
                }
            },
            {
                pattern: /innerHTML\s*=\s*.*\+/g,
                type: 'xss',
                category: 'Cross-Site Scripting',
                title: 'DOM-based XSS via innerHTML',
                description: 'Direct assignment to innerHTML with concatenated user input can lead to XSS attacks',
                impact: 'Script injection, session hijacking, defacement',
                remediation: 'Use textContent, createTextNode, or sanitize HTML input',
                severity: 'high',
                cwe: 'CWE-79',
                cvss: 7.5,
                fix: {
                    description: 'Use textContent instead of innerHTML',
                    suggestion: 'element.textContent = userInput; // Safe from XSS'
                }
            },
            {
                pattern: /document\.write\s*\(/g,
                type: 'xss',
                category: 'Cross-Site Scripting',
                title: 'document.write() XSS vulnerability',
                description: 'document.write() can be exploited for XSS attacks',
                impact: 'Script injection, content manipulation',
                remediation: 'Use modern DOM manipulation methods instead',
                severity: 'medium',
                cwe: 'CWE-79',
                cvss: 6.0
            },

            // Authentication & Authorization
            {
                pattern: /localStorage\.setItem\s*\(\s*['"].*token.*['"],/g,
                type: 'auth',
                category: 'Insecure Storage',
                title: 'Sensitive token stored in localStorage',
                description: 'Storing authentication tokens in localStorage is vulnerable to XSS attacks',
                impact: 'Token theft, session hijacking',
                remediation: 'Use httpOnly cookies or secure session storage',
                severity: 'high',
                cwe: 'CWE-922',
                cvss: 7.0
            },
            {
                pattern: /sessionStorage\.setItem\s*\(\s*['"].*password.*['"],/g,
                type: 'auth',
                category: 'Insecure Storage',
                title: 'Password stored in sessionStorage',
                description: 'Storing passwords in browser storage is a security risk',
                impact: 'Credential exposure, unauthorized access',
                remediation: 'Never store passwords in client-side storage',
                severity: 'critical',
                cwe: 'CWE-256',
                cvss: 8.5
            },

            // Cryptography
            {
                pattern: /Math\.random\(\)/g,
                type: 'crypto',
                category: 'Weak Cryptography',
                title: 'Weak random number generation',
                description: 'Math.random() is not cryptographically secure',
                impact: 'Predictable values, cryptographic weakness',
                remediation: 'Use crypto.getRandomValues() for security-sensitive random numbers',
                severity: 'medium',
                cwe: 'CWE-338',
                cvss: 5.0,
                fix: {
                    description: 'Use crypto.getRandomValues() for secure random numbers',
                    suggestion: 'crypto.getRandomValues(new Uint32Array(1))[0]'
                }
            },
            {
                pattern: /btoa\s*\(/g,
                type: 'crypto',
                category: 'Weak Encoding',
                title: 'Base64 encoding used for security',
                description: 'Base64 is encoding, not encryption. It provides no security',
                impact: 'Data exposure, false sense of security',
                remediation: 'Use proper encryption for sensitive data',
                severity: 'low',
                cwe: 'CWE-326'
            },

            // Secret Detection
            {
                pattern: /api[_-]?key\s*[=:]\s*['"][a-zA-Z0-9]{20,}['"]/gi,
                type: 'secrets',
                category: 'Exposed Secrets',
                title: 'API key exposed in code',
                description: 'Hard-coded API keys can be extracted from source code',
                impact: 'Unauthorized API access, service abuse',
                remediation: 'Use environment variables or secure key management',
                severity: 'critical',
                cwe: 'CWE-798',
                cvss: 9.0
            },
            {
                pattern: /password\s*[=:]\s*['"][^'"]+['"]/gi,
                type: 'secrets',
                category: 'Exposed Secrets',
                title: 'Hard-coded password',
                description: 'Passwords should never be hard-coded in source code',
                impact: 'Unauthorized access, credential compromise',
                remediation: 'Use secure configuration management',
                severity: 'critical',
                cwe: 'CWE-259',
                cvss: 8.0
            },
            {
                pattern: /token\s*[=:]\s*['"][a-zA-Z0-9+/]{40,}['"]/gi,
                type: 'secrets',
                category: 'Exposed Secrets',
                title: 'Authentication token in code',
                description: 'Hard-coded tokens compromise security',
                impact: 'Token abuse, unauthorized access',
                remediation: 'Use environment variables for tokens',
                severity: 'high',
                cwe: 'CWE-798',
                cvss: 7.5
            },

            // Configuration Issues
            {
                pattern: /console\.log\s*\([^)]*password[^)]*\)/gi,
                type: 'configuration',
                category: 'Information Disclosure',
                title: 'Password logged to console',
                description: 'Logging sensitive information can expose it in production',
                impact: 'Information disclosure, log pollution',
                remediation: 'Remove sensitive data from logs',
                severity: 'medium',
                cwe: 'CWE-532',
                cvss: 5.5
            },
            {
                pattern: /fetch\s*\(\s*['"]http:\/\//g,
                type: 'configuration',
                category: 'Insecure Communication',
                title: 'Insecure HTTP request',
                description: 'Using HTTP instead of HTTPS exposes data in transit',
                impact: 'Data interception, man-in-the-middle attacks',
                remediation: 'Use HTTPS for all external communications',
                severity: 'medium',
                cwe: 'CWE-319',
                cvss: 6.0
            },

            // Denial of Service
            {
                pattern: /while\s*\(\s*true\s*\)/g,
                type: 'dos',
                category: 'Infinite Loop',
                title: 'Potential infinite loop',
                description: 'Infinite loops can cause denial of service',
                impact: 'Application hang, resource exhaustion',
                remediation: 'Add proper loop termination conditions',
                severity: 'medium',
                cwe: 'CWE-835',
                cvss: 5.0
            }
        ];
    }

    private async scanSourceCode(targetPath: string, includeTests: boolean, workspaceRoot: string): Promise<SecurityVulnerability[]> {
        const vulnerabilities: SecurityVulnerability[] = [];
        const files = await this.collectFiles(targetPath, includeTests);

        for (const file of files) {
            const content = fs.readFileSync(file, 'utf8');
            const relativePath = path.relative(workspaceRoot, file);
            const lines = content.split('\n');

            // Check each vulnerability pattern
            for (const pattern of this.vulnerabilityPatterns) {
                let match;
                while ((match = pattern.pattern.exec(content)) !== null) {
                    const lineNumber = content.substring(0, match.index).split('\n').length;
                    
                    vulnerabilities.push({
                        file: relativePath,
                        line: lineNumber,
                        severity: pattern.severity,
                        type: pattern.type,
                        category: pattern.category,
                        title: pattern.title,
                        description: pattern.description,
                        impact: pattern.impact,
                        remediation: pattern.remediation,
                        cwe: pattern.cwe,
                        cvss: pattern.cvss,
                        code: lines[lineNumber - 1]?.trim(),
                        fix: pattern.fix
                    });
                }
            }
        }

        return vulnerabilities;
    }

    private async scanDependencies(workspaceRoot: string): Promise<SecurityVulnerability[]> {
        const vulnerabilities: SecurityVulnerability[] = [];
        
        try {
            const packageJsonPath = path.join(workspaceRoot, 'package.json');
            if (fs.existsSync(packageJsonPath)) {
                const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
                const dependencies = { ...packageJson.dependencies, ...packageJson.devDependencies };

                // Known vulnerable packages (simplified - in production, use actual vulnerability databases)
                const knownVulnerablePackages = {
                    'lodash': { versions: ['<4.17.21'], cve: 'CVE-2021-23337', severity: 'high' as const },
                    'minimist': { versions: ['<1.2.6'], cve: 'CVE-2021-44906', severity: 'medium' as const },
                    'handlebars': { versions: ['<4.7.7'], cve: 'CVE-2021-23369', severity: 'medium' as const },
                    'serialize-javascript': { versions: ['<6.0.0'], cve: 'CVE-2022-25645', severity: 'high' as const }
                };

                Object.entries(dependencies).forEach(([pkg, version]) => {
                    if (knownVulnerablePackages[pkg]) {
                        const vuln = knownVulnerablePackages[pkg];
                        vulnerabilities.push({
                            file: 'package.json',
                            line: 1,
                            severity: vuln.severity,
                            type: 'dependencies',
                            category: 'Vulnerable Dependency',
                            title: `Vulnerable package: ${pkg}`,
                            description: `Package ${pkg} version ${version} has known security vulnerabilities`,
                            impact: 'Potential security compromise through dependency',
                            remediation: `Update ${pkg} to a secure version`,
                            cwe: 'CWE-1104',
                            code: `"${pkg}": "${version}"`
                        });
                    }
                });
            }
        } catch (error) {
            // Package.json analysis failed, continue without it
        }

        return vulnerabilities;
    }

    private async scanConfiguration(workspaceRoot: string): Promise<SecurityVulnerability[]> {
        const vulnerabilities: SecurityVulnerability[] = [];
        
        // Check for insecure configuration files
        const configFiles = [
            '.env',
            'config.js',
            'config.json',
            'webpack.config.js',
            'next.config.js'
        ];

        for (const configFile of configFiles) {
            const configPath = path.join(workspaceRoot, configFile);
            if (fs.existsSync(configPath)) {
                const content = fs.readFileSync(configPath, 'utf8');
                
                // Check for exposed secrets in config
                if (/password|secret|key|token/i.test(content) && !/example|sample|placeholder/i.test(content)) {
                    vulnerabilities.push({
                        file: configFile,
                        line: 1,
                        severity: 'high',
                        type: 'configuration',
                        category: 'Insecure Configuration',
                        title: 'Potential secrets in configuration file',
                        description: 'Configuration file may contain sensitive information',
                        impact: 'Information disclosure, credential exposure',
                        remediation: 'Use environment variables for sensitive configuration'
                    });
                }
            }
        }

        return vulnerabilities;
    }

    private async scanSecrets(targetPath: string, workspaceRoot: string): Promise<SecurityVulnerability[]> {
        const vulnerabilities: SecurityVulnerability[] = [];
        const files = await this.collectFiles(targetPath, false);

        // Enhanced secret patterns
        const secretPatterns = [
            { pattern: /sk_live_[a-zA-Z0-9]{24,}/g, name: 'Stripe Live API Key' },
            { pattern: /sk_test_[a-zA-Z0-9]{24,}/g, name: 'Stripe Test API Key' },
            { pattern: /AKIA[0-9A-Z]{16}/g, name: 'AWS Access Key ID' },
            { pattern: /ghp_[a-zA-Z0-9]{36}/g, name: 'GitHub Personal Access Token' },
            { pattern: /glpat-[a-zA-Z0-9\-_]{20}/g, name: 'GitLab Personal Access Token' },
            { pattern: /xoxb-[0-9]{11}-[0-9]{11}-[a-zA-Z0-9]{24}/g, name: 'Slack Bot Token' },
            { pattern: /AIza[0-9A-Za-z\-_]{35}/g, name: 'Google API Key' },
            { pattern: /ya29\.[a-zA-Z0-9\-_]{60,}/g, name: 'Google OAuth Access Token' }
        ];

        for (const file of files) {
            const content = fs.readFileSync(file, 'utf8');
            const relativePath = path.relative(workspaceRoot, file);
            const lines = content.split('\n');

            for (const { pattern, name } of secretPatterns) {
                let match;
                while ((match = pattern.exec(content)) !== null) {
                    const lineNumber = content.substring(0, match.index).split('\n').length;
                    
                    vulnerabilities.push({
                        file: relativePath,
                        line: lineNumber,
                        severity: 'critical',
                        type: 'secrets',
                        category: 'Exposed Secrets',
                        title: `${name} exposed in code`,
                        description: `A ${name} was found hard-coded in the source code`,
                        impact: 'Unauthorized access to external services, financial loss',
                        remediation: 'Remove the secret and use environment variables instead',
                        cwe: 'CWE-798',
                        cvss: 9.0,
                        code: lines[lineNumber - 1]?.trim()
                    });
                }
            }
        }

        return vulnerabilities;
    }

    private async collectFiles(targetPath: string, includeTests: boolean): Promise<string[]> {
        const files: string[] = [];
        
        if (fs.statSync(targetPath).isFile()) {
            if (this.isScannableFile(targetPath, includeTests)) {
                return [targetPath];
            }
            return [];
        }

        const collectRecursively = (dir: string) => {
            const entries = fs.readdirSync(dir);
            
            for (const entry of entries) {
                const fullPath = path.join(dir, entry);
                const stat = fs.statSync(fullPath);
                
                if (stat.isDirectory()) {
                    if (!['node_modules', '.git', 'dist', 'build', 'coverage'].includes(entry)) {
                        collectRecursively(fullPath);
                    }
                } else if (stat.isFile() && this.isScannableFile(fullPath, includeTests)) {
                    files.push(fullPath);
                }
            }
        };

        collectRecursively(targetPath);
        return files;
    }

    private isScannableFile(filePath: string, includeTests: boolean): boolean {
        const ext = path.extname(filePath);
        const isSourceFile = ['.ts', '.tsx', '.js', '.jsx', '.mjs', '.vue', '.svelte'].includes(ext);
        
        if (!isSourceFile) return false;
        
        if (!includeTests) {
            const fileName = path.basename(filePath);
            return !/\.(test|spec)\.(ts|js|tsx|jsx)$/.test(fileName);
        }
        
        return true;
    }

    private filterBySeverity(vulnerabilities: SecurityVulnerability[], minSeverity: string): SecurityVulnerability[] {
        const severityOrder = ['info', 'low', 'medium', 'high', 'critical'];
        const minIndex = severityOrder.indexOf(minSeverity);
        
        if (minIndex === -1) return vulnerabilities;
        
        return vulnerabilities.filter(vuln => severityOrder.indexOf(vuln.severity) >= minIndex);
    }

    private generateSecurityReport(vulnerabilities: SecurityVulnerability[], compliance: string[]): SecurityReport {
        const summary = {
            totalVulnerabilities: vulnerabilities.length,
            critical: vulnerabilities.filter(v => v.severity === 'critical').length,
            high: vulnerabilities.filter(v => v.severity === 'high').length,
            medium: vulnerabilities.filter(v => v.severity === 'medium').length,
            low: vulnerabilities.filter(v => v.severity === 'low').length,
            byType: vulnerabilities.reduce((acc, v) => {
                acc[v.type] = (acc[v.type] || 0) + 1;
                return acc;
            }, {} as { [type: string]: number }),
            riskScore: this.calculateRiskScore(vulnerabilities)
        };

        const recommendations = this.generateRecommendations(vulnerabilities);
        const complianceStatus = this.checkCompliance(vulnerabilities, compliance);

        return {
            summary,
            vulnerabilities,
            recommendations,
            compliance: complianceStatus
        };
    }

    private calculateRiskScore(vulnerabilities: SecurityVulnerability[]): number {
        const weights = { critical: 25, high: 10, medium: 5, low: 2, info: 1 };
        const totalScore = vulnerabilities.reduce((score, vuln) => {
            return score + (weights[vuln.severity] || 0);
        }, 0);
        
        // Normalize to 0-100 scale (assuming 10 critical vulnerabilities = 100% risk)
        return Math.min(100, Math.round((totalScore / 250) * 100));
    }

    private generateRecommendations(vulnerabilities: SecurityVulnerability[]): string[] {
        const recommendations: string[] = [];
        
        const criticalCount = vulnerabilities.filter(v => v.severity === 'critical').length;
        const secretsCount = vulnerabilities.filter(v => v.type === 'secrets').length;
        const xssCount = vulnerabilities.filter(v => v.type === 'xss').length;
        const injectionCount = vulnerabilities.filter(v => v.type === 'injection').length;

        if (criticalCount > 0) {
            recommendations.push(`🚨 Address ${criticalCount} critical vulnerabilities immediately`);
        }
        
        if (secretsCount > 0) {
            recommendations.push('🔐 Implement proper secrets management (environment variables, key vaults)');
        }
        
        if (xssCount > 0) {
            recommendations.push('🛡️ Implement input validation and output encoding to prevent XSS');
        }
        
        if (injectionCount > 0) {
            recommendations.push('💉 Review and sanitize all user inputs to prevent injection attacks');
        }

        recommendations.push('📋 Implement regular security code reviews');
        recommendations.push('🔄 Set up automated security scanning in CI/CD pipeline');
        recommendations.push('📚 Provide security training for development team');

        return recommendations;
    }

    private checkCompliance(vulnerabilities: SecurityVulnerability[], standards: string[]): { owasp: string[]; pci: boolean; gdpr: boolean } {
        const owaspTop10 = [];
        const hasXSS = vulnerabilities.some(v => v.type === 'xss');
        const hasInjection = vulnerabilities.some(v => v.type === 'injection');
        const hasAuth = vulnerabilities.some(v => v.type === 'auth');
        const hasCrypto = vulnerabilities.some(v => v.type === 'crypto');
        
        if (hasInjection) owaspTop10.push('A03:2021 – Injection');
        if (hasXSS) owaspTop10.push('A07:2021 – Cross-Site Scripting (XSS)');
        if (hasAuth) owaspTop10.push('A07:2021 – Identification and Authentication Failures');
        if (hasCrypto) owaspTop10.push('A02:2021 – Cryptographic Failures');

        return {
            owasp: owaspTop10,
            pci: vulnerabilities.filter(v => v.severity === 'critical').length === 0,
            gdpr: !vulnerabilities.some(v => v.type === 'secrets' || (v.type === 'configuration' && v.title.includes('password')))
        };
    }

    private async applyAutoFixes(vulnerabilities: SecurityVulnerability[], context: { workspaceRoot: string; outputChannel: any }): Promise<number> {
        let fixedCount = 0;

        // Group by file
        const vulnsByFile = vulnerabilities.reduce((acc, vuln) => {
            if (!acc[vuln.file]) acc[vuln.file] = [];
            acc[vuln.file].push(vuln);
            return acc;
        }, {} as { [file: string]: SecurityVulnerability[] });

        for (const [file, fileVulns] of Object.entries(vulnsByFile)) {
            const filePath = path.resolve(context.workspaceRoot, file);
            
            if (!fs.existsSync(filePath)) continue;
            
            let content = fs.readFileSync(filePath, 'utf8');
            let modified = false;

            // Apply fixes for low severity issues with available fixes
            for (const vuln of fileVulns) {
                if (vuln.severity === 'low' && vuln.fix) {
                    try {
                        // Simple fix application (could be enhanced)
                        if (vuln.type === 'crypto' && vuln.title.includes('Math.random')) {
                            content = content.replace(/Math\.random\(\)/g, 'crypto.getRandomValues(new Uint32Array(1))[0] / 2**32');
                            modified = true;
                            fixedCount++;
                        }
                    } catch (error) {
                        context.outputChannel.appendLine(`Failed to apply fix for ${vuln.title}: ${error}`);
                    }
                }
            }

            if (modified) {
                fs.writeFileSync(filePath, content, 'utf8');
                context.outputChannel.appendLine(`Applied security fixes to ${file}`);
            }
        }

        return fixedCount;
    }

    private async generateHtmlReport(report: SecurityReport, workspaceRoot: string): Promise<string> {
        const reportPath = path.join(workspaceRoot, 'security-report.html');
        
        const html = `
<!DOCTYPE html>
<html>
<head>
    <title>Security Vulnerability Report</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .header { background: #f5f5f5; padding: 20px; border-radius: 5px; margin-bottom: 20px; }
        .risk-score { font-size: 2em; color: ${report.summary.riskScore >= 70 ? '#d32f2f' : report.summary.riskScore >= 40 ? '#f57c00' : '#388e3c'}; }
        .summary { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; margin: 20px 0; }
        .summary-card { background: white; border: 1px solid #ddd; padding: 15px; border-radius: 5px; text-align: center; }
        .vulnerability { margin: 15px 0; padding: 15px; border-left: 4px solid #ddd; background: #f9f9f9; }
        .critical { border-left-color: #d32f2f; background: #ffeaea; }
        .high { border-left-color: #f57c00; background: #fff3e0; }
        .medium { border-left-color: #1976d2; background: #e3f2fd; }
        .low { border-left-color: #388e3c; background: #e8f5e8; }
        .code { background: #f5f5f5; padding: 10px; border-radius: 3px; font-family: monospace; margin: 10px 0; }
        .recommendations { background: #e8f5e8; padding: 15px; border-radius: 5px; margin: 20px 0; }
        .compliance { background: #e3f2fd; padding: 15px; border-radius: 5px; margin: 20px 0; }
    </style>
</head>
<body>
    <div class="header">
        <h1>Security Vulnerability Report</h1>
        <div class="risk-score">Risk Score: ${report.summary.riskScore}/100</div>
        <p>Generated: ${new Date().toISOString()}</p>
    </div>
    
    <h2>Summary</h2>
    <div class="summary">
        <div class="summary-card">
            <h3>Total</h3>
            <div style="font-size: 2em;">${report.summary.totalVulnerabilities}</div>
        </div>
        <div class="summary-card">
            <h3>Critical</h3>
            <div style="font-size: 2em; color: #d32f2f;">${report.summary.critical}</div>
        </div>
        <div class="summary-card">
            <h3>High</h3>
            <div style="font-size: 2em; color: #f57c00;">${report.summary.high}</div>
        </div>
        <div class="summary-card">
            <h3>Medium</h3>
            <div style="font-size: 2em; color: #1976d2;">${report.summary.medium}</div>
        </div>
        <div class="summary-card">
            <h3>Low</h3>
            <div style="font-size: 2em; color: #388e3c;">${report.summary.low}</div>
        </div>
    </div>
    
    <div class="recommendations">
        <h2>🎯 Key Recommendations</h2>
        ${report.recommendations.map(rec => `<p>• ${rec}</p>`).join('')}
    </div>
    
    <div class="compliance">
        <h2>📋 Compliance Status</h2>
        <p><strong>OWASP Top 10 Issues:</strong> ${report.compliance.owasp.length > 0 ? report.compliance.owasp.join(', ') : 'None detected'}</p>
        <p><strong>PCI DSS Compliant:</strong> ${report.compliance.pci ? '✅ Yes' : '❌ No'}</p>
        <p><strong>GDPR Compliant:</strong> ${report.compliance.gdpr ? '✅ Yes' : '❌ No'}</p>
    </div>
    
    <h2>🔍 Vulnerabilities</h2>
    ${report.vulnerabilities.map(vuln => `
        <div class="vulnerability ${vuln.severity}">
            <h3>${vuln.title}</h3>
            <p><strong>File:</strong> ${vuln.file}:${vuln.line}</p>
            <p><strong>Severity:</strong> ${vuln.severity.toUpperCase()}</p>
            <p><strong>Type:</strong> ${vuln.type}</p>
            <p><strong>Description:</strong> ${vuln.description}</p>
            <p><strong>Impact:</strong> ${vuln.impact}</p>
            <p><strong>Remediation:</strong> ${vuln.remediation}</p>
            ${vuln.cwe ? `<p><strong>CWE:</strong> ${vuln.cwe}</p>` : ''}
            ${vuln.cvss ? `<p><strong>CVSS Score:</strong> ${vuln.cvss}</p>` : ''}
            ${vuln.code ? `<div class="code">${vuln.code}</div>` : ''}
            ${vuln.fix ? `<p><strong>Quick Fix:</strong> ${vuln.fix.suggestion}</p>` : ''}
        </div>
    `).join('')}
</body>
</html>`;
        
        fs.writeFileSync(reportPath, html, 'utf8');
        return reportPath;
    }

    private formatResults(report: SecurityReport, fixedCount: number, reportPath?: string): string {
        let message = `Security scan completed! 🔒\n`;
        message += `📊 Risk Score: ${report.summary.riskScore}/100\n`;
        message += `🔍 Found ${report.summary.totalVulnerabilities} vulnerabilities:\n`;
        
        if (report.summary.critical > 0) message += `  🔴 Critical: ${report.summary.critical}\n`;
        if (report.summary.high > 0) message += `  🟠 High: ${report.summary.high}\n`;
        if (report.summary.medium > 0) message += `  🟡 Medium: ${report.summary.medium}\n`;
        if (report.summary.low > 0) message += `  🟢 Low: ${report.summary.low}\n`;
        
        if (fixedCount > 0) {
            message += `\n✅ Auto-fixed ${fixedCount} low-risk issues`;
        }
        
        if (report.compliance.owasp.length > 0) {
            message += `\n⚠️ OWASP Top 10 violations detected`;
        }
        
        if (reportPath) {
            message += `\n📄 Detailed report: ${path.basename(reportPath)}`;
        }

        return message;
    }
}

export default new SecurityVulnerabilityTool();
